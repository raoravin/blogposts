---
title: 'Next.js Server Actions with next-safe-action'
description: 'The next-safe-action library handles server action type safety, input validation, errors and more.'
date: '2024-06-18'
modified: '2024-06-18'
tags: ['nextjs','typesafety','validation','serveractions','rsc']
cover_image: "data:image/png;base64,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"
---

**TLDR:** Add type safe and validated server actions to your Next.js App Router project with next-safe-action.

## Next.js Server Actions

[Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations) are asynchronous functions executed on the server in Next.js. 

They are defined with the `"use server"` directive and can be used 
in both server and client components for handling form submissions and data mutations.

Over the last year, I've seen them applied in a variety of ways, and I've used them in projects myself, too.

Now, I have recently discovered the [next-safe-action](https://next-safe-action.dev/) library, and I like the structure, ease-of-use, and extra features it provides. 

## An Example Server Action without next-safe-action

I think the best way to show why I like [next-safe-action](https://next-safe-action.dev/) is to show how I implemented a Next.js server action without the library first. 

Afterwards, I will show the refactor with [next-safe-action](https://next-safe-action.dev/).

Here's an example server action from a repository and tutorial I recently published on creating a [Next.js Modal Form with react-hook-form, ShadCN/ui, Server Actions and Zod validation](https://youtu.be/WyL_Jc6_-sY).


```ts
// src/app/actions/actions.ts
"use server"

import { UserSchema } from "@/schemas/User"
import type { User } from "@/schemas/User"

type ReturnType = {
    message: string,
    errors?: Record<string, unknown>
}

export async function saveUser(user: User): Promise<ReturnType> {

    // Check valid login here
    
    const parsed = UserSchema.safeParse(user)

    if (!parsed.success) {
        return {
            message: "Submission Failed",
            errors: parsed.error.flatten().fieldErrors
        }
    }

    await fetch(`http://localhost:3500/users/${user.id}`, {
        method: 'PATCH',
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            firstname: user.firstname,
            lastname: user.lastname,
            email: user.email,
        })
    })

    return { message: "User Updated! ðŸŽ‰" }
}
```
You can see above that I was using a local `json-server` instance in the tutorial to update user data. 

Before the update occurs, the data is validated with [Zod](https://zod.dev/). 

If the validation fails, Zod validation errors are sent back to the client component with the ZodError type `flatten` method applied. 

Now let's compare to the refactored version using [next-safe-action](https://next-safe-action.dev/).

## An Example Server Action with next-safe-action

```ts 
// src/app/actions/actions.ts
"use server"

import { UserSchema } from "@/schemas/User"
import { actionClient } from "@/lib/safe-action"
import { flattenValidationErrors } from "next-safe-action"

export const saveUserAction = actionClient
    .schema(UserSchema, {
        handleValidationErrorsShape: (ve) => flattenValidationErrors(ve).fieldErrors,
    })
    .action(async ({ parsedInput: { id, firstname, lastname, email } }) => {

        // Check valid login here

        await fetch(`http://localhost:3500/users/${id}`, {
            method: 'PATCH',
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                firstname: firstname,
                lastname: lastname,
                email: email,
            })
        })

        return { message: "User Updated! ðŸŽ‰" }
    })
```
The file has shrunk down from 33 lines to 26 lines of code.

Starting at the top you can see I still import the Zod UserSchema I have defined. The inferred User type is no longer imported. 

New imports include `actionClient` and `flattenValidationErrors`. 

Instead of `export async function`, I'm using `export const` and starting the definition of `saveUserAction` with the `actionClient`. 

I chain the `schema` method to the `actionClient` while passing in the `UserSchema`. I also set the `handleValidationErrorsShape` option to use the imported `flattenValidationErrors` method. This method is similar to the ZodError type method `flatten` that I used in the original function.

Next, I chain the `action` method and call the async function inside of it. It supplies a `parsedInput` prop. I destructure the prop to get the input data sent to the server action. 

The remainder of the function remains unchanged. 

Note that in this refactored version I did not define a `ReturnType`. 

The return type is the result defined by the [useAction hook return object](https://next-safe-action.dev/docs/execution/hooks/useaction#useaction-return-object). I apply the `useAction` hook in the client component. 

While some overhead is saved in the server action code you see above, even more is saved in the client component. 

Below, I again show before and after code versions. This time the before and afters are of the client component using [react-hook-form](https://react-hook-form.com/).

## An Example Client Component without next-safe-action
 
```ts 
// src/app/edit/[id]/UserForm.tsx
"use client"

import { useForm } from "react-hook-form"
import { Form } from "@/components/ui/form"
import { Button } from "@/components/ui/button"
import { InputWithLabel } from "@/components/InputWithLabel"
import { zodResolver } from "@hookform/resolvers/zod"
import { UserSchema } from "@/schemas/User"
import type { User } from "@/schemas/User"
import { saveUser } from "@/app/actions/actions"
import { useState, useEffect } from "react"
import { useRouter } from "next/navigation"

type Props = {
    user: User
}

export default function UserForm({ user }: Props) {
    const [message, setMessage] = useState('')
    const [errors, setErrors] = useState({})
    const router = useRouter()

    const form = useForm<User>({
        mode: 'onBlur',
        resolver: zodResolver(UserSchema),
        defaultValues: { ...user },
    })

    useEffect(() => {
        // boolean to indicate if form has not been saved
        localStorage.setItem("userFormModified", form.formState.isDirty.toString())
    }, [form.formState.isDirty])

    async function onSubmit() {
        setMessage('')
        setErrors({})
        /* No need to validate here because 
        react-hook-form already validates with 
        the Zod schema */
        const result = await saveUser(form.getValues())
        if (result?.errors) {
            setMessage(result.message)
            setErrors(result.errors)
            return
        } else {
            setMessage(result.message)
            // update client-side cache
            router.refresh() 
            // reset dirty fields
            form.reset(form.getValues())
        }
    }

    return (
        <div>
            {message ? (
                <h2 className="text-2xl">{message}</h2>
            ) : null}

            {errors ? (
                <div className="mb-10 text-red-500">
                    {Object.keys(errors).map(key => (
                        <p key={key}>{`${key}: ${errors[key as keyof typeof errors]}`}</p>
                    ))}
                </div>
            ) : null}

            <Form {...form}>
                <form onSubmit={(e) => {
                    e.preventDefault()
                    form.handleSubmit(onSubmit)();
                }} className="flex flex-col gap-4">

                    <InputWithLabel
                        fieldTitle="First Name"
                        nameInSchema="firstname"
                    />
                    <InputWithLabel
                        fieldTitle="Last Name"
                        nameInSchema="lastname"
                    />
                    <InputWithLabel
                        fieldTitle="Email"
                        nameInSchema="email"
                    />
                    <div className="flex gap-4">
                        <Button>Submit</Button>
                        <Button
                            type="button"
                            variant="destructive"
                            onClick={() => form.reset()}
                        >Reset</Button>
                    </div>
                </form>
            </Form>
        </div>
    )
}
```
In the above example, I had to set state for both the message and errors that the original server action could return. 

I also needed to consider that state in the onSubmit function. 

In the refactored version below, you can see how this is simplified.

## An Example Client Component with next-safe-action

```ts
// src/app/edit/[id]/UserForm.tsx
"use client"

import { useForm } from "react-hook-form"
import { Form } from "@/components/ui/form"
import { Button } from "@/components/ui/button"
import { InputWithLabel } from "@/components/InputWithLabel"
import { zodResolver } from "@hookform/resolvers/zod"
import { UserSchema } from "@/schemas/User"
import type { User } from "@/schemas/User"
import { saveUserAction } from "@/app/actions/actions"
import { useEffect } from "react"
import { useRouter } from "next/navigation"

import { useAction } from "next-safe-action/hooks"
import { DisplayServerActionResponse } from "@/components/DisplayServerActionResponse"

type Props = {
    user: User
}

export default function UserForm({ user }: Props) {
    const router = useRouter()
    const { execute, result, isExecuting } = useAction(saveUserAction)

    const form = useForm<User>({
        resolver: zodResolver(UserSchema),
        defaultValues: { ...user },
    })

    useEffect(() => {
        // boolean to indicate if form has not been saved
        localStorage.setItem("userFormModified", form.formState.isDirty.toString())
    }, [form.formState.isDirty])

    async function onSubmit() {
        /* No need to validate here because 
        react-hook-form already validates with 
        the Zod schema */
        execute(form.getValues())
        // update client-side cache
        router.refresh()
        // reset dirty fields
        form.reset(form.getValues())
    }

    return (
        <div>
            <DisplayServerActionResponse result={result} />

            <Form {...form}>
                <form onSubmit={(e) => {
                    e.preventDefault()
                    form.handleSubmit(onSubmit)();
                }} className="flex flex-col gap-4">

                    <InputWithLabel
                        fieldTitle="First Name"
                        nameInSchema="firstname"
                    />
                    <InputWithLabel
                        fieldTitle="Last Name"
                        nameInSchema="lastname"
                    />
                    <InputWithLabel
                        fieldTitle="Email"
                        nameInSchema="email"
                    />
                    <div className="flex gap-4">
                        <Button>{isExecuting ? "Working..." : "Submit"}</Button>
                        <Button
                            type="button"
                            variant="destructive"
                            onClick={() => form.reset()}
                        >Reset</Button>
                    </div>
                </form>
            </Form>
        </div>
    )
}
```
In this refactored version, I imported the [useAction](https://next-safe-action.dev/docs/execution/hooks/useaction) hook supplied by next-safe-action and a custom component I created called `DisplayServerActionResponse`.

I eliminated all usage of `useState`.

`DisplayServerActionResponse` receives the `result` that is provided by the useAction hook. It holds the data sent back from the server action. 

`useAction` also provides an `execute` function and an `isExecuting` boolean. (Check the [docs](https://next-safe-action.dev/docs/introduction) for what else it can provide, too.)

All of this greatly reduces the logic I needed to put in the `onSubmit` function. 

Receiving the `result` from the server action makes it easy to abstract the displayed response to the custom `DisplayServerActionResponse` component, too. 

Here's a quick look at that component as well..

## Displaying the Server Action Result 

```ts
type Props = {
    result: {
        data?: {
            message?: string,
        },
        serverError?: string,
        fetchError?: string,
        validationErrors?: Record<string, string[] | undefined> | undefined,
    }
}

export function DisplayServerActionResponse({ result }: Props) {

    const { data, serverError, fetchError, validationErrors } = result

    return (
        <>
            {/* Success Message */}
            {data?.message ? (
                <h2 className="text-2xl my-2">{data.message}</h2>
            ) : null}

            {serverError ? (
                <div className="my-2 text-red-500">
                    <p>{serverError}</p>
                </div>
            ) : null}

            {fetchError ? (
                <div className="my-2 text-red-500">
                    <p>{fetchError}</p>
                </div>
            ) : null}

            {validationErrors ? (
                <div className="my-2 text-red-500">
                    {Object.keys(validationErrors).map(key => (
                        <p key={key}>{`${key}: ${validationErrors && validationErrors[key as keyof typeof validationErrors]}`}</p>
                    ))}
                </div>
            ) : null}
        </>
    )
}
```
Above, you can see that [next-safe-action](https://next-safe-action.dev/) provides not only validation errors from the Zod schema I constructed, but it also provides server errors and fetch errors. 

In addition, the result object contains the success message I provided from the server action. 

## Learn More

This is just one example and a simple one at that! Dive into the docs and solve your own specific use case to see what else [next-safe-action](https://next-safe-action.dev/) is capable of. 

I plan to refactor my old server actions and use next-safe-action going forward. 




